android-28流程

准备显示软键盘

# ViewRootImpl

* ViewRootImpl#forceLayout()
  
  * view.forceLayout // DecorView[LoginActivity]
  
* handleWindowFocusChanged

  * InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
        imm.onPreWindowFocus(mView, hasWindowFocus);
    }

  * 

  * 

  * 

    

  #### dispatchCheckFocus

  ```
  public void dispatchCheckFocus() {
      if (!mHandler.hasMessages(MSG_CHECK_FOCUS)) {
          // This will result in a call to checkFocus() below.
          mHandler.sendEmptyMessage(MSG_CHECK_FOCUS);
      }
  }
  ```

## MSG_CHECK_FOCUS

```
MSG_CHECK_FOCUS

InputMethodManager imm = InputMethodManager.peekInstance();
if (imm != null) {
    imm.checkFocus();
}
```

## doTraversal

## performTraversals





## MSG_RESIZED_REPORT

```
case MSG_RESIZED_REPORT:
    if (mAdded) {
        SomeArgs args = (SomeArgs) msg.obj;
        final int displayId = args.argi3;
        MergedConfiguration mergedConfiguration = (MergedConfiguration) args.arg4;
        final boolean displayChanged = mDisplay.getDisplayId() != displayId;
        if (!mLastReportedMergedConfiguration.equals(mergedConfiguration)) {
            // If configuration changed - notify about that and, maybe,
            // about move to display.
            performConfigurationChange(mergedConfiguration, false /* force */,
                    displayChanged
                            ? displayId : INVALID_DISPLAY /* same display */);
        } else if (displayChanged) {
            // Moved to display without config change - report last applied one.
            onMovedToDisplay(displayId, mLastConfigurationFromResources);
        }
        final boolean framesChanged = !mWinFrame.equals(args.arg1)
                || !mPendingOverscanInsets.equals(args.arg5)
                || !mPendingContentInsets.equals(args.arg2)
                || !mPendingStableInsets.equals(args.arg6)
                || !mPendingDisplayCutout.get().equals(args.arg9)
                || !mPendingVisibleInsets.equals(args.arg3)
                || !mPendingOutsets.equals(args.arg7);
        mWinFrame.set((Rect) args.arg1);
        mPendingOverscanInsets.set((Rect) args.arg5);
        mPendingContentInsets.set((Rect) args.arg2);
        mPendingStableInsets.set((Rect) args.arg6);
        mPendingDisplayCutout.set((DisplayCutout) args.arg9);
        mPendingVisibleInsets.set((Rect) args.arg3);
        mPendingOutsets.set((Rect) args.arg7);
        mPendingBackDropFrame.set((Rect) args.arg8);
        mForceNextWindowRelayout = args.argi1 != 0;
        mPendingAlwaysConsumeNavBar = args.argi2 != 0;
        args.recycle();
        if (msg.what == MSG_RESIZED_REPORT) {
            reportNextDraw();
        }
        if (mView != null && framesChanged) {
            forceLayout(mView);
        }
        requestLayout();
    }
    break;
```





## MSG_RESIED

```
// Recycled in the fall through...
SomeArgs args = (SomeArgs) msg.obj;
if (mWinFrame.equals(args.arg1)
        && mPendingOverscanInsets.equals(args.arg5)
        && mPendingContentInsets.equals(args.arg2)
        && mPendingStableInsets.equals(args.arg6)
        && mPendingDisplayCutout.get().equals(args.arg9)
        && mPendingVisibleInsets.equals(args.arg3)
        && mPendingOutsets.equals(args.arg7)
        && mPendingBackDropFrame.equals(args.arg8)
        && args.arg4 == null
        && args.argi1 == 0
        && mDisplay.getDisplayId() == args.argi3) {
    break;
}
```



## dispatchResized

```
private void dispatchResized(Rect frame, Rect overscanInsets, Rect contentInsets,
        Rect visibleInsets, Rect stableInsets, Rect outsets, boolean reportDraw,
        MergedConfiguration mergedConfiguration, Rect backDropFrame, boolean forceLayout,
        boolean alwaysConsumeNavBar, int displayId,
        DisplayCutout.ParcelableWrapper displayCutout) {
    if (DEBUG_LAYOUT) Log.v(mTag, "Resizing " + this + ": frame=" + frame.toShortString()
            + " contentInsets=" + contentInsets.toShortString()
            + " visibleInsets=" + visibleInsets.toShortString()
            + " reportDraw=" + reportDraw
            + " backDropFrame=" + backDropFrame);
    // Tell all listeners that we are resizing the window so that the chrome can get
    // updated as fast as possible on a separate thread,
    if (mDragResizing && mUseMTRenderer) {
        boolean fullscreen = frame.equals(backDropFrame);
        synchronized (mWindowCallbacks) {
            for (int i = mWindowCallbacks.size() - 1; i >= 0; i--) {
                mWindowCallbacks.get(i).onWindowSizeIsChanging(backDropFrame, fullscreen,
                        visibleInsets, stableInsets);
            }
        }
    }
    Message msg = mHandler.obtainMessage(reportDraw ? MSG_RESIZED_REPORT : MSG_RESIZED);
    if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWindow(frame);
        mTranslator.translateRectInScreenToAppWindow(overscanInsets);
        mTranslator.translateRectInScreenToAppWindow(contentInsets);
        mTranslator.translateRectInScreenToAppWindow(visibleInsets);
    }
    SomeArgs args = SomeArgs.obtain();
    final boolean sameProcessCall = (Binder.getCallingPid() == android.os.Process.myPid());
    args.arg1 = sameProcessCall ? new Rect(frame) : frame;
    args.arg2 = sameProcessCall ? new Rect(contentInsets) : contentInsets;
    args.arg3 = sameProcessCall ? new Rect(visibleInsets) : visibleInsets;
    args.arg4 = sameProcessCall && mergedConfiguration != null
            ? new MergedConfiguration(mergedConfiguration) : mergedConfiguration;
    args.arg5 = sameProcessCall ? new Rect(overscanInsets) : overscanInsets;
    args.arg6 = sameProcessCall ? new Rect(stableInsets) : stableInsets;
    args.arg7 = sameProcessCall ? new Rect(outsets) : outsets;
    args.arg8 = sameProcessCall ? new Rect(backDropFrame) : backDropFrame;
    args.arg9 = displayCutout.get(); // DisplayCutout is immutable.
    args.argi1 = forceLayout ? 1 : 0;
    args.argi2 = alwaysConsumeNavBar ? 1 : 0;
    args.argi3 = displayId;
    msg.obj = args;
    mHandler.sendMessage(msg);
}
```



## IWindow.Stub#resized

```
@Override
public void resized(Rect frame, Rect overscanInsets, Rect contentInsets,
        Rect visibleInsets, Rect stableInsets, Rect outsets, boolean reportDraw,
        MergedConfiguration mergedConfiguration, Rect backDropFrame, boolean forceLayout,
        boolean alwaysConsumeNavBar, int displayId,
        DisplayCutout.ParcelableWrapper displayCutout) {
    final ViewRootImpl viewAncestor = mViewAncestor.get();
    if (viewAncestor != null) {
        viewAncestor.dispatchResized(frame, overscanInsets, contentInsets,
                visibleInsets, stableInsets, outsets, reportDraw, mergedConfiguration,
                backDropFrame, forceLayout, alwaysConsumeNavBar, displayId, displayCutout);
    }
}
```



# View.java





## handleFocusGainInternal

```
/**
 * Give this view focus. This will cause
 * {@link #onFocusChanged(boolean, int, android.graphics.Rect)} to be called.
 *
 * Note: this does not check whether this {@link View} should get focus, it just
 * gives it focus no matter what.  It should only be called internally by framework
 * code that knows what it is doing, namely {@link #requestFocus(int, Rect)}.
 *
 * @param direction values are {@link View#FOCUS_UP}, {@link View#FOCUS_DOWN},
 *        {@link View#FOCUS_LEFT} or {@link View#FOCUS_RIGHT}. This is the direction which
 *        focus moved when requestFocus() is called. It may not always
 *        apply, in which case use the default View.FOCUS_DOWN.
 * @param previouslyFocusedRect The rectangle of the view that had focus
 *        prior in this View's coordinate system.
 */
void handleFocusGainInternal(@FocusRealDirection int direction, Rect previouslyFocusedRect) {
    if (DBG) {
        System.out.println(this + " requestFocus()");
    }
    if ((mPrivateFlags & PFLAG_FOCUSED) == 0) {
        mPrivateFlags |= PFLAG_FOCUSED;
        View oldFocus = (mAttachInfo != null) ? getRootView().findFocus() : null;
        if (mParent != null) {
            mParent.requestChildFocus(this, this);
            updateFocusedInCluster(oldFocus, direction);
        }
        if (mAttachInfo != null) {
            mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, this);
        }
        onFocusChanged(true, direction, previouslyFocusedRect);
        refreshDrawableState();
    }
}
```



## **dispatchWindowFocusChanged**

## **onWindowFocusChanged**

```
/**
 * Called when the window containing this view gains or loses focus.  Note
 * that this is separate from view focus: to receive key events, both
 * your view and its window must have focus.  If a window is displayed
 * on top of yours that takes input focus, then your own window will lose
 * focus but the view focus will remain unchanged.
 *
 * @param hasWindowFocus True if the window containing this view now has
 *        focus, false otherwise.
 */
public void onWindowFocusChanged(boolean hasWindowFocus) {
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (!hasWindowFocus) {
        if (isPressed()) {
            setPressed(false);
        }
        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
        if (imm != null && (mPrivateFlags & PFLAG_FOCUSED) != 0) {
            imm.focusOut(this);
        }
        removeLongPressCallback();
        removeTapCallback();
        onFocusLost();
    } else if (imm != null && (mPrivateFlags & PFLAG_FOCUSED) != 0) {
        imm.focusIn(this);
    }
    refreshDrawableState();
}
```



## onFocusChanged

```
InputMethodManager imm = InputMethodManager.peekInstance();
if (!gainFocus) {
    if (isPressed()) {
        setPressed(false);
    }
    if (imm != null && mAttachInfo != null && mAttachInfo.mHasWindowFocus) {
        imm.focusOut(this);
    }
    onFocusLost();
} else if (imm != null && mAttachInfo != null && mAttachInfo.mHasWindowFocus) {
    imm.focusIn(this);
}
```







* View#invalidate
  * mLeft = 0  mBottom = 1488.  mRight = 1080. mTop = 1375。invalidateCache = true

* View#invalidateInternal
  * damage --> Rect(5, 20 - 20, 91)
* View#drawableStateChanged
  * super.updateTextColors();
  * --> 调用了invalidate
* View#sertPressed
  * dispatchSetPressed(presse) // true
* View#onTouchEvent



#EditText & TextView

* TextView(EditText super class) # onTouchEvent

  * final boolean superResult = super.onTouchEvent(event)

  * final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) 

    && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused() 

  * ```
    if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
        // Show the IME, except when selecting in read-only text.
        final InputMethodManager imm = InputMethodManager.peekInstance();
        viewClicked(imm);
        if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null) {
            imm.showSoftInput(this, 0);
        }
        // The above condition ensures that the mEditor is not null
        mEditor.onTouchUpEvent(event);
        handled = true;
    }
    	
    	
    ```



# InputMethodManager

## startInputInner

```
boolean startInputInner(@InputMethodClient.StartInputReason final int startInputReason,
        IBinder windowGainingFocus, int controlFlags, int softInputMode,
        int windowFlags) {
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, "Starting input: view=" + dumpViewInfo(view) +
                    " reason=" + InputMethodClient.getStartInputReason(startInputReason));
        }
        if (view == null) {
            if (DEBUG) Log.v(TAG, "ABORT input: no served view!");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // If the view doesn't have a handler, something has changed out
        // from under us, so just close the current input.
        // If we don't close the current input, the current input method can remain on the
        // screen without a connection.
        if (DEBUG) Log.v(TAG, "ABORT input: no handler for view! Close current input.");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // The view is running on a different thread than our own, so
        // we need to reschedule our work for over there.
        if (DEBUG) Log.v(TAG, "Starting input: reschedule to view thread");
        vh.post(() -> startInputInner(startInputReason, null, 0, 0, 0));
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG) Log.v(TAG, "Starting input: tba=" + tba + " ic=" + ic);
    synchronized (mH) {
        // Now that we are locked again, validate that our state hasn't
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG) Log.v(TAG,
                    "Starting input: finished by someone else. view=" + dumpViewInfo(view)
                    + " mServedView=" + dumpViewInfo(mServedView)
                    + " mServedConnecting=" + mServedConnecting);
            return false;
        }
        // If we already have a text box, then this view is already
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        ControlledInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            final Handler icHandler;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER)
                    != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new ControlledInputConnectionWrapper(
                    icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG) Log.v(TAG, "START INPUT: view=" + dumpViewInfo(view) + " ic="
                    + ic + " tba=" + tba + " controlFlags=#"
                    + Integer.toHexString(controlFlags));
            final InputBindResult res = mService.startInputOrWindowGainedFocus(
                    startInputReason, mClient, windowGainingFocus, controlFlags, softInputMode,
                    windowFlags, tba, servedContext, missingMethodFlags,
                    view.getContext().getApplicationInfo().targetSdkVersion);
            if (DEBUG) Log.v(TAG, "Starting input: Bind result=" + res);
            if (res == null) {
                Log.wtf(TAG, "startInputOrWindowGainedFocus must not return"
                        + " null. startInputReason="
                        + InputMethodClient.getStartInputReason(startInputReason)
                        + " editorInfo=" + tba
                        + " controlFlags=#" + Integer.toHexString(controlFlags));
                return false;
            }
            if (res.id != null) {
                setInputChannelLocked(res.channel);
                mBindSequence = res.sequence;
                mCurMethod = res.method;
                mCurId = res.id;
                mNextUserActionNotificationSequenceNumber =
                        res.userActionNotificationSequenceNumber;
            } else if (res.channel != null && res.channel != mCurChannel) {
                res.channel.dispose();
            }
            switch (res.result) {
                case InputBindResult.ResultCode.ERROR_NOT_IME_TARGET_WINDOW:
                    mRestartOnNextWindowFocus = true;
                    break;
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
        }
    }
    return true;
```





## focusIn->focusInLocked

```
/**
 * Call this when a view receives focus.
 * @hide
 */
public void focusIn(View view) {
    synchronized (mH) {
        focusInLocked(view);
    }
}
```

* InputMethodMananger#viewClicked

  * ```
    /**
     * Notify the event when the user tapped or clicked the text view.
     */
    public void viewClicked(View view) {
        final boolean focusChanged = mServedView != mNextServedView;
        checkFocus();
        synchronized (mH) {
            if ((mServedView != view && (mServedView == null
                    || !mServedView.checkInputConnectionProxy(view)))
                    || mCurrentTextBoxAttribute == null || mCurMethod == null) {
                return;
            }
            try {
                if (DEBUG) Log.v(TAG, "onViewClicked: " + focusChanged);
                mCurMethod.viewClicked(focusChanged);
            } catch (RemoteException e) {
                Log.w(TAG, "IME died: " + mCurId, e);
            }
        }
    }
    ```

* InputMethodManager#showSoftInput

  * mService.showSoftInput(mClient, flags, resultReceiver)

* InputMethodManager imm = InputMethodManager.peekInstance();
  if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
      imm.onPreWindowFocus(mView, hasWindowFocus);
  }



## onPreWindowFocus

```
/** @hide */
public void onPreWindowFocus(View rootView, boolean hasWindowFocus) {
    synchronized (mH) {
        if (rootView == null) {
            mCurRootView = null;
        } if (hasWindowFocus) {
            mCurRootView = rootView;
        } else if (rootView == mCurRootView) {
            // If the mCurRootView is losing window focus, release the strong reference to it
            // so as not to prevent it from being garbage-collected.
            mCurRootView = null;
        } else {
            if (DEBUG) {
                Log.v(TAG, "Ignoring onPreWindowFocus()."
                        + " mCurRootView=" + mCurRootView + " rootView=" + rootView);
            }
        }
    }
}
```



## **scheduleCheckFocusLocked**

```
static void scheduleCheckFocusLocked(View view) {
    ViewRootImpl viewRootImpl = view.getViewRootImpl();
    if (viewRootImpl != null) {
        viewRootImpl.dispatchCheckFocus();
    }
}
```







# InputManagerService



## ViewTreeObserver.OnComputeInternalInsetsListener

```
final ViewTreeObserver.OnComputeInternalInsetsListener mInsetsComputer = info -> {
    if (isExtractViewShown()) {
        // In true fullscreen mode, we just say the window isn't covering
        // any content so we don't impact whatever is behind.
        View decor = getWindow().getWindow().getDecorView();
        info.contentInsets.top = info.visibleInsets.top = decor.getHeight();
        info.touchableRegion.setEmpty();
        info.setTouchableInsets(ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_FRAME);
    } else {
        onComputeInsets(mTmpInsets);
        info.contentInsets.top = mTmpInsets.contentTopInsets;
        info.visibleInsets.top = mTmpInsets.visibleTopInsets;
        info.touchableRegion.set(mTmpInsets.touchableRegion);
        info.setTouchableInsets(mTmpInsets.touchableInsets);
    }
};
```



## updateExtractFrameVisibility

```
void updateExtractFrameVisibility() {
    final int vis;
    if (isFullscreenMode()) {
        vis = mExtractViewHidden ? View.INVISIBLE : View.VISIBLE;
        // "vis" should be applied for the extract frame as well in the fullscreen mode.
        mExtractFrame.setVisibility(vis);
    } else {
        vis = View.VISIBLE;
        mExtractFrame.setVisibility(View.GONE);
    }
    updateCandidatesVisibility(mCandidatesVisibility == View.VISIBLE);
    if (mWindowWasVisible && mFullscreenArea.getVisibility() != vis) {
        int animRes = mThemeAttrs.getResourceId(vis == View.VISIBLE
                ? com.android.internal.R.styleable.InputMethodService_imeExtractEnterAnimation
                : com.android.internal.R.styleable.InputMethodService_imeExtractExitAnimation,
                0);
        if (animRes != 0) {
            mFullscreenArea.startAnimation(AnimationUtils.loadAnimation(
                    this, animRes));
        }
    }
    mFullscreenArea.setVisibility(vis);
}
```



## onCreate

```
@Override public void onCreate() {
    mTheme = Resources.selectSystemTheme(mTheme,
            getApplicationInfo().targetSdkVersion,
            android.R.style.Theme_InputMethod,
            android.R.style.Theme_Holo_InputMethod,
            android.R.style.Theme_DeviceDefault_InputMethod,
            android.R.style.Theme_DeviceDefault_InputMethod);
    super.setTheme(mTheme);
    super.onCreate();
    mImm = (InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
    mSettingsObserver = SettingsObserver.createAndRegister(this);
    // If the previous IME has occupied non-empty inset in the screen, we need to decide whether
    // we continue to use the same size of the inset or update it
    mShouldClearInsetOfPreviousIme = (mImm.getInputMethodWindowVisibleHeight() > 0);
    mInflater = (LayoutInflater)getSystemService(
            Context.LAYOUT_INFLATER_SERVICE);
    mWindow = new SoftInputWindow(this, "InputMethod", mTheme, null, null, mDispatcherState,
            WindowManager.LayoutParams.TYPE_INPUT_METHOD, Gravity.BOTTOM, false);
    // For ColorView in DecorView to work, FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS needs to be set
    // by default (but IME developers can opt this out later if they want a new behavior).
    mWindow.getWindow().setFlags(
            FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS, FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
    initViews();
    mWindow.getWindow().setLayout(MATCH_PARENT, WRAP_CONTENT);
```





## showWindowInner(boolean showInput)

```
void showWindowInner(boolean showInput) {
    boolean doShowInput = false;
    final int previousImeWindowStatus =
            (mWindowVisible ? IME_ACTIVE : 0) | (isInputViewShown() ? IME_VISIBLE : 0);
    mWindowVisible = true;
    if (!mShowInputRequested && mInputStarted && showInput) {
        doShowInput = true;
        mShowInputRequested = true;
    }
    if (DEBUG) Log.v(TAG, "showWindow: updating UI");
    initialize();
    updateFullscreenMode();
    updateInputViewShown();
    
    if (!mWindowAdded || !mWindowCreated) {
        mWindowAdded = true;
        mWindowCreated = true;
        initialize();
        if (DEBUG) Log.v(TAG, "CALL: onCreateCandidatesView");
        View v = onCreateCandidatesView();
        if (DEBUG) Log.v(TAG, "showWindow: candidates=" + v);
        if (v != null) {
            setCandidatesView(v);
        }
    }
    if (mShowInputRequested) {
        if (!mInputViewStarted) {
            if (DEBUG) Log.v(TAG, "CALL: onStartInputView");
            mInputViewStarted = true;
            onStartInputView(mInputEditorInfo, false);
        }
    } else if (!mCandidatesViewStarted) {
        if (DEBUG) Log.v(TAG, "CALL: onStartCandidatesView");
        mCandidatesViewStarted = true;
        onStartCandidatesView(mInputEditorInfo, false);
    }
    
    if (doShowInput) {
        startExtractingText(false);
    }
    final int nextImeWindowStatus = mapToImeWindowStatus(isInputViewShown());
    if (previousImeWindowStatus != nextImeWindowStatus) {
        mImm.setImeWindowStatus(mToken, mStartInputToken, nextImeWindowStatus,
                mBackDisposition);
    }
    if ((previousImeWindowStatus & IME_ACTIVE) == 0) {
        if (DEBUG) Log.v(TAG, "showWindow: showing!");
        onWindowShown();
        mWindow.show();
        // Put here rather than in onWindowShown() in case people forget to call
        // super.onWindowShown().
        mShouldClearInsetOfPreviousIme = false;
    }
}
```





## onConfigureWindow

```
/**
 * Update the given window's parameters for the given mode.  This is called
 * when the window is first displayed and each time the fullscreen or
 * candidates only mode changes.
 * 
 * <p>The default implementation makes the layout for the window
 * MATCH_PARENT x MATCH_PARENT when in fullscreen mode, and
 * MATCH_PARENT x WRAP_CONTENT when in non-fullscreen mode.
 * 
 * @param win The input method's window.
 * @param isFullscreen If true, the window is running in fullscreen mode
 * and intended to cover the entire application display.
 * @param isCandidatesOnly If true, the window is only showing the
 * candidates view and none of the rest of its UI.  This is mutually
 * exclusive with fullscreen mode.
 */
public void onConfigureWindow(Window win, boolean isFullscreen,
        boolean isCandidatesOnly) {
    final int currentHeight = mWindow.getWindow().getAttributes().height;
    final int newHeight = isFullscreen ? MATCH_PARENT : WRAP_CONTENT;
    if (mIsInputViewShown && currentHeight != newHeight) {
        if (DEBUG) {
            Log.w(TAG,"Window size has been changed. This may cause jankiness of resizing "
                    + "window: " + currentHeight + " -> " + newHeight);
        }
    }
    mWindow.getWindow().setLayout(MATCH_PARENT, newHeight);
}
```



## onComputeInsets(Insets outInsets)

```
/**
 * Compute the interesting insets into your UI.  The default implementation
 * uses the top of the candidates frame for the visible insets, and the
 * top of the input frame for the content insets.  The default touchable
 * insets are {@link Insets#TOUCHABLE_INSETS_VISIBLE}.
 * 
 * <p>Note that this method is not called when
 * {@link #isExtractViewShown} returns true, since
 * in that case the application is left as-is behind the input method and
 * not impacted by anything in its UI.
 * 
 * @param outInsets Fill in with the current UI insets.
 */
public void onComputeInsets(Insets outInsets) {
    int[] loc = mTmpLocation;
    if (mInputFrame.getVisibility() == View.VISIBLE) {
        mInputFrame.getLocationInWindow(loc);
    } else {
        View decor = getWindow().getWindow().getDecorView();
        loc[1] = decor.getHeight();
    }
    if (isFullscreenMode()) {
        // In fullscreen mode, we never resize the underlying window.
        View decor = getWindow().getWindow().getDecorView();
        outInsets.contentTopInsets = decor.getHeight();
    } else {
        outInsets.contentTopInsets = loc[1];
    }
    if (mCandidatesFrame.getVisibility() == View.VISIBLE) {
        mCandidatesFrame.getLocationInWindow(loc);
    }
    outInsets.visibleTopInsets = loc[1];
    outInsets.touchableInsets = Insets.TOUCHABLE_INSETS_VISIBLE;
    outInsets.touchableRegion.setEmpty();
}
```





# AbstractInputmethodService

## onBind

```
@Override
final public IBinder onBind(Intent intent) {
    if (mInputMethod == null) {
        mInputMethod = onCreateInputMethodInterface();
    }
    return new IInputMethodWrapper(this, mInputMethod);
}
```



# IInputMethodWrapper

## showSoftInput

```
final HandlerCaller mCaller;

@BinderThread
@Override
public void showSoftInput(int flags, ResultReceiver resultReceiver) {
    mCaller.executeOrSendMessage(mCaller.obtainMessageIO(DO_SHOW_SOFT_INPUT,
            flags, resultReceiver));
}
```





# InputMethodImpl#InputmethodServcie

## showSoftInput

```
@MainThread
@Override
public void showSoftInput(int flags, ResultReceiver resultReceiver) {
	boolean wasVis = isInputViewShow();
	if(dispatchOnShowInputRequest(flags, false)){
		try{
			showWindow(true);
		} catch(BadTokenException e) {
			
		}
	}
	clearInsetOfPreviousIme();
	mImm.setImeWindowStatus(mToken, mStartInputToken,
		mapToImeWindowStatus(isInputViewShow()), mBackDisposition);
	if(resultReceiver != null) {
		resultReceiver.send(wasVis  != isInputViewShow() 
			? InputMethodManager.RESULT_SHOWN
			: (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOW
				: InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
	}
}
```

## showWindow

## showWindowInner

updateFullscreenMode

updateInputViewShown()











# ViewGroup.java

* dispatchTransformedTouchEvent



# MyEditText.java

* getLocationInWindow
  * 2275 2447
  * 1509 1681
  * 766  766



# MyNestedScrollView.java



# TextView.java

## onCreateInputConnection

```
@Override
public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
            outAttrs.hintLocales = mEditor.mInputContentType.imeHintLocales;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
            outAttrs.hintLocales = null;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION)
                == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a "done" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            return ic;
        }
    }
    return null;
}
```





# computeScroll # MyNsetedScrollView

```
0 = {StackTraceElement@11446} "dalvik.system.VMStack.getThreadStackTrace(Native Method)"
1 = {StackTraceElement@11447} "java.lang.Thread.getStackTrace(Thread.java:1538)"
2 = {StackTraceElement@11448} "cn.kuwo.pp.ui.login.MyNestedScrollView.computeScroll(MyNestedScrollView.kt:1656)"
3 = {StackTraceElement@11449} "android.view.View.updateDisplayListIfDirty(View.java:19065)"
4 = {StackTraceElement@11450} "android.view.View.draw(View.java:19935)"
5 = {StackTraceElement@11451} "android.view.ViewGroup.drawChild(ViewGroup.java:4333)"
6 = {StackTraceElement@11452} "android.view.ViewGroup.dispatchDraw(ViewGroup.java:4112)"
7 = {StackTraceElement@11453} "android.view.View.draw(View.java:20210)"
8 = {StackTraceElement@11454} "android.view.View.updateDisplayListIfDirty(View.java:19082)"
9 = {StackTraceElement@11455} "android.view.View.draw(View.java:19935)"
10 = {StackTraceElement@11456} "android.view.ViewGroup.drawChild(ViewGroup.java:4333)"
11 = {StackTraceElement@11457} "android.view.ViewGroup.dispatchDraw(ViewGroup.java:4112)"
12 = {StackTraceElement@11458} "android.view.View.updateDisplayListIfDirty(View.java:19073)"
13 = {StackTraceElement@11459} "android.view.View.draw(View.java:19935)"
14 = {StackTraceElement@11460} "android.view.ViewGroup.drawChild(ViewGroup.java:4333)"
15 = {StackTraceElement@11461} "android.view.ViewGroup.dispatchDraw(ViewGroup.java:4112)"
16 = {StackTraceElement@11462} "android.view.View.updateDisplayListIfDirty(View.java:19073)"
17 = {StackTraceElement@11463} "android.view.View.draw(View.java:19935)"
18 = {StackTraceElement@11464} "android.view.ViewGroup.drawChild(ViewGroup.java:4333)"
19 = {StackTraceElement@11465} "android.view.ViewGroup.dispatchDraw(ViewGroup.java:4112)"
20 = {StackTraceElement@11466} "android.view.View.updateDisplayListIfDirty(View.java:19073)"
21 = {StackTraceElement@11467} "android.view.View.draw(View.java:19935)"
22 = {StackTraceElement@11468} "android.view.ViewGroup.drawChild(ViewGroup.java:4333)"
23 = {StackTraceElement@11469} "android.view.ViewGroup.dispatchDraw(ViewGroup.java:4112)"
24 = {StackTraceElement@11470} "android.view.View.updateDisplayListIfDirty(View.java:19073)"
25 = {StackTraceElement@11471} "android.view.View.draw(View.java:19935)"
26 = {StackTraceElement@11472} "android.view.ViewGroup.drawChild(ViewGroup.java:4333)"
27 = {StackTraceElement@11473} "android.view.ViewGroup.dispatchDraw(ViewGroup.java:4112)"
28 = {StackTraceElement@11474} "android.view.View.updateDisplayListIfDirty(View.java:19073)"
29 = {StackTraceElement@11475} "android.view.View.draw(View.java:19935)"
30 = {StackTraceElement@11476} "android.view.ViewGroup.drawChild(ViewGroup.java:4333)"
31 = {StackTraceElement@11477} "android.view.ViewGroup.dispatchDraw(ViewGroup.java:4112)"
32 = {StackTraceElement@11478} "android.view.View.draw(View.java:20210)"
33 = {StackTraceElement@11479} "com.android.internal.policy.DecorView.draw(DecorView.java:780)"
34 = {StackTraceElement@11480} "android.view.View.updateDisplayListIfDirty(View.java:19082)"
35 = {StackTraceElement@11481} "android.view.ThreadedRenderer.updateViewTreeDisplayList(ThreadedRenderer.java:686)"
36 = {StackTraceElement@11482} "android.view.ThreadedRenderer.updateRootDisplayList(ThreadedRenderer.java:692)"
37 = {StackTraceElement@11483} "android.view.ThreadedRenderer.draw(ThreadedRenderer.java:801)"
38 = {StackTraceElement@11484} "android.view.ViewRootImpl.draw(ViewRootImpl.java:3311)"
39 = {StackTraceElement@11485} "android.view.ViewRootImpl.performDraw(ViewRootImpl.java:3115)"
40 = {StackTraceElement@11486} "android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2484)"
41 = {StackTraceElement@11487} "android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1460)"
42 = {StackTraceElement@11488} "android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:7183)"
43 = {StackTraceElement@11489} "android.view.Choreographer$CallbackRecord.run(Choreographer.java:949)"
44 = {StackTraceElement@11490} "android.view.Choreographer.doCallbacks(Choreographer.java:761)"
45 = {StackTraceElement@11491} "android.view.Choreographer.doFrame(Choreographer.java:696)"
46 = {StackTraceElement@11492} "android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:935)"
47 = {StackTraceElement@11493} "android.os.Handler.handleCallback(Handler.java:873)"
48 = {StackTraceElement@11494} "android.os.Handler.dispatchMessage(Handler.java:99)"
49 = {StackTraceElement@11495} "android.os.Looper.loop(Looper.java:193)"
50 = {StackTraceElement@11496} "android.app.ActivityThread.main(ActivityThread.java:6669)"
51 = {StackTraceElement@11497} "java.lang.reflect.Method.invoke(Native Method)"
52 = {StackTraceElement@11498} "com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)"
53 = {StackTraceElement@11499} "com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)"
```



# forceLayout # MyNestedScrollView

```
0 = {StackTraceElement@11594} "dalvik.system.VMStack.getThreadStackTrace(Native Method)"
1 = {StackTraceElement@11595} "java.lang.Thread.getStackTrace(Thread.java:1538)"
2 = {StackTraceElement@11596} "cn.kuwo.pp.ui.login.MyNestedScrollView.forceLayout(MyNestedScrollView.kt:2310)"
3 = {StackTraceElement@11597} "android.view.ViewRootImpl.forceLayout(ViewRootImpl.java:3964)"
4 = {StackTraceElement@11598} "android.view.ViewRootImpl.forceLayout(ViewRootImpl.java:3969)"
5 = {StackTraceElement@11599} "android.view.ViewRootImpl.forceLayout(ViewRootImpl.java:3969)"
6 = {StackTraceElement@11600} "android.view.ViewRootImpl.forceLayout(ViewRootImpl.java:3969)"
7 = {StackTraceElement@11601} "android.view.ViewRootImpl.forceLayout(ViewRootImpl.java:3969)"
8 = {StackTraceElement@11602} "android.view.ViewRootImpl.forceLayout(ViewRootImpl.java:3969)"
9 = {StackTraceElement@11603} "android.view.ViewRootImpl.forceLayout(ViewRootImpl.java:3969)"
10 = {StackTraceElement@11604} "android.view.ViewRootImpl.forceLayout(ViewRootImpl.java:3969)"
11 = {StackTraceElement@11605} "android.view.ViewRootImpl.access$700(ViewRootImpl.java:132)"
12 = {StackTraceElement@11606} "android.view.ViewRootImpl$ViewRootHandler.handleMessage(ViewRootImpl.java:4154)"
13 = {StackTraceElement@11607} "android.os.Handler.dispatchMessage(Handler.java:106)"
14 = {StackTraceElement@11608} "android.os.Looper.loop(Looper.java:193)"
15 = {StackTraceElement@11609} "android.app.ActivityThread.main(ActivityThread.java:6669)"
16 = {StackTraceElement@11610} "java.lang.reflect.Method.invoke(Native Method)"
17 = {StackTraceElement@11611} "com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)"
18 = {StackTraceElement@11612} "com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)"
```





# IInputMethodManager.aidl

```
package com.android.internal.view;

import android.net.Uri;
import android.os.ResultReceiver;
import android.text.style.SuggestionSpan;
import android.view.inputmethod.InputMethodInfo;
import android.view.inputmethod.InputMethodSubtype;
import android.view.inputmethod.EditorInfo;
import com.android.internal.inputmethod.IInputContentUriToken;
import com.android.internal.view.InputBindResult;
import com.android.internal.view.IInputContext;
import com.android.internal.view.IInputMethodClient;

/**
 * Public interface to the global input method manager, used by all client
 * applications.
 * You need to update BridgeIInputMethodManager.java as well when changing
 * this file.
 */
interface IInputMethodManager {
    // TODO: Use ParceledListSlice instead
    List<InputMethodInfo> getInputMethodList();
    List<InputMethodInfo> getVrInputMethodList();
    // TODO: Use ParceledListSlice instead
    List<InputMethodInfo> getEnabledInputMethodList();
    List<InputMethodSubtype> getEnabledInputMethodSubtypeList(in String imiId,
            boolean allowsImplicitlySelectedSubtypes);
    InputMethodSubtype getLastInputMethodSubtype();
    // TODO: We should change the return type from List to List<Parcelable>
    // Currently there is a bug that aidl doesn't accept List<Parcelable>
    List getShortcutInputMethodsAndSubtypes();
    void addClient(in IInputMethodClient client,
            in IInputContext inputContext, int uid, int pid);
    void removeClient(in IInputMethodClient client);

    void finishInput(in IInputMethodClient client);
    // showSoftInput
    boolean showSoftInput(in IInputMethodClient client, int flags,
            in ResultReceiver resultReceiver);
    boolean hideSoftInput(in IInputMethodClient client, int flags,
            in ResultReceiver resultReceiver);
    // If windowToken is null, this just does startInput().  Otherwise this reports that a window
    // has gained focus, and if 'attribute' is non-null then also does startInput.
    // @NonNull
    InputBindResult startInputOrWindowGainedFocus(
            /* @InputMethodClient.StartInputReason */ int startInputReason,
            in IInputMethodClient client, in IBinder windowToken, int controlFlags,
            /* @android.view.WindowManager.LayoutParams.SoftInputModeFlags */ int softInputMode,
            int windowFlags, in EditorInfo attribute, IInputContext inputContext,
            /* @InputConnectionInspector.MissingMethodFlags */ int missingMethodFlags,
            int unverifiedTargetSdkVersion);

    void showInputMethodPickerFromClient(in IInputMethodClient client,
            int auxiliarySubtypeMode);
    void showInputMethodAndSubtypeEnablerFromClient(in IInputMethodClient client, String topId);
    boolean isInputMethodPickerShownForTest();
    void setInputMethod(in IBinder token, String id);
    void setInputMethodAndSubtype(in IBinder token, String id, in InputMethodSubtype subtype);
    void hideMySoftInput(in IBinder token, int flags);
    void showMySoftInput(in IBinder token, int flags);
    void updateStatusIcon(in IBinder token, String packageName, int iconId);
    void setImeWindowStatus(in IBinder token, in IBinder startInputToken, int vis,
            int backDisposition);
    void registerSuggestionSpansForNotification(in SuggestionSpan[] spans);
    boolean notifySuggestionPicked(in SuggestionSpan span, String originalString, int index);
    InputMethodSubtype getCurrentInputMethodSubtype();
    boolean setCurrentInputMethodSubtype(in InputMethodSubtype subtype);
    boolean switchToPreviousInputMethod(in IBinder token);
    boolean switchToNextInputMethod(in IBinder token, boolean onlyCurrentIme);
    boolean shouldOfferSwitchingToNextInputMethod(in IBinder token);
    void setAdditionalInputMethodSubtypes(String id, in InputMethodSubtype[] subtypes);
    int getInputMethodWindowVisibleHeight();
    void clearLastInputMethodWindowForTransition(in IBinder token);

    IInputContentUriToken createInputContentUriToken(in IBinder token, in Uri contentUri,
            in String packageName);

    void reportFullscreenMode(in IBinder token, boolean fullscreen);

    oneway void notifyUserAction(int sequenceNumber);
}
```



# IWindow.aidl

```
/* //device/java/android/android/view/IWindow.aidl
**
** Copyright 2007, The Android Open Source Project
**
** Licensed under the Apache License, Version 2.0 (the "License"); 
** you may not use this file except in compliance with the License. 
** You may obtain a copy of the License at 
**
**     http://www.apache.org/licenses/LICENSE-2.0 
**
** Unless required by applicable law or agreed to in writing, software 
** distributed under the License is distributed on an "AS IS" BASIS, 
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
** See the License for the specific language governing permissions and 
** limitations under the License.
*/

package android.view;

import android.graphics.Rect;
import android.os.Bundle;
import android.os.ParcelFileDescriptor;
import android.view.DragEvent;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.DisplayCutout;

import com.android.internal.os.IResultReceiver;
import android.util.MergedConfiguration;

/**
 * API back to a client window that the Window Manager uses to inform it of
 * interesting things happening.
 *
 * {@hide}
 */
oneway interface IWindow {
    /**
     * ===== NOTICE =====
     * The first method must remain the first method. Scripts
     * and tools rely on their transaction number to work properly.
     */

    /**
     * Invoked by the view server to tell a window to execute the specified
     * command. Any response from the receiver must be sent through the
     * specified file descriptor.
     */
    void executeCommand(String command, String parameters, in ParcelFileDescriptor descriptor);

    void resized(in Rect frame, in Rect overscanInsets, in Rect contentInsets,
            in Rect visibleInsets, in Rect stableInsets, in Rect outsets, boolean reportDraw,
            in MergedConfiguration newMergedConfiguration, in Rect backDropFrame,
            boolean forceLayout, boolean alwaysConsumeNavBar, int displayId,
            in DisplayCutout.ParcelableWrapper displayCutout);
    void moved(int newX, int newY);
    void dispatchAppVisibility(boolean visible);
    void dispatchGetNewSurface();

    /**
     * Tell the window that it is either gaining or losing focus.  Keep it up
     * to date on the current state showing navigational focus (touch mode) too.
     */
    void windowFocusChanged(boolean hasFocus, boolean inTouchMode);
    
    void closeSystemDialogs(String reason);
    
    /**
     * Called for wallpaper windows when their offsets change.
     */
    void dispatchWallpaperOffsets(float x, float y, float xStep, float yStep, boolean sync);
    
    void dispatchWallpaperCommand(String action, int x, int y,
            int z, in Bundle extras, boolean sync);

    /**
     * Drag/drop events
     */
    void dispatchDragEvent(in DragEvent event);

    /**
     * Pointer icon events
     */
    void updatePointerIcon(float x, float y);

    /**
     * System chrome visibility changes
     */
    void dispatchSystemUiVisibilityChanged(int seq, int globalVisibility,
            int localValue, int localChanges);

    /**
     * Called for non-application windows when the enter animation has completed.
     */
    void dispatchWindowShown();

    /**
     * Called when Keyboard Shortcuts are requested for the window.
     */
    void requestAppKeyboardShortcuts(IResultReceiver receiver, int deviceId);

    /**
     * Tell the window that it is either gaining or losing pointer capture.
     */
    void dispatchPointerCaptureChanged(boolean hasCapture);
}
```



# IWindowSession.aidl

```
/* //device/java/android/android/view/IWindowSession.aidl
**
** Copyright 2006, The Android Open Source Project
**
** Licensed under the Apache License, Version 2.0 (the "License"); 
** you may not use this file except in compliance with the License. 
** You may obtain a copy of the License at 
**
**     http://www.apache.org/licenses/LICENSE-2.0 
**
** Unless required by applicable law or agreed to in writing, software 
** distributed under the License is distributed on an "AS IS" BASIS, 
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
** See the License for the specific language governing permissions and
** limitations under the License.
*/

package android.view;

import android.content.ClipData;
import android.graphics.Rect;
import android.graphics.Region;
import android.os.Bundle;
import android.util.MergedConfiguration;
import android.view.DisplayCutout;
import android.view.InputChannel;
import android.view.IWindow;
import android.view.IWindowId;
import android.view.MotionEvent;
import android.view.WindowManager;
import android.view.Surface;
import android.view.SurfaceControl;

/**
 * System private per-application interface to the window manager.
 *
 * {@hide}
 */
interface IWindowSession {
    int add(IWindow window, int seq, in WindowManager.LayoutParams attrs,
            in int viewVisibility, out Rect outContentInsets, out Rect outStableInsets,
            out InputChannel outInputChannel);
    int addToDisplay(IWindow window, int seq, in WindowManager.LayoutParams attrs,
            in int viewVisibility, in int layerStackId, out Rect outFrame,
            out Rect outContentInsets, out Rect outStableInsets, out Rect outOutsets,
            out DisplayCutout.ParcelableWrapper displayCutout, out InputChannel outInputChannel);
    int addWithoutInputChannel(IWindow window, int seq, in WindowManager.LayoutParams attrs,
            in int viewVisibility, out Rect outContentInsets, out Rect outStableInsets);
    int addToDisplayWithoutInputChannel(IWindow window, int seq, in WindowManager.LayoutParams attrs,
            in int viewVisibility, in int layerStackId, out Rect outContentInsets,
            out Rect outStableInsets);
    void remove(IWindow window);

    /**
     * Change the parameters of a window.  You supply the
     * new parameters, it returns the new frame of the window on screen (the
     * position should be ignored) and surface of the window.  The surface
     * will be invalid if the window is currently hidden, else you can use it
     * to draw the window's contents.
     * 
     * @param window The window being modified.
     * @param seq Ordering sequence number.
     * @param attrs If non-null, new attributes to apply to the window.
     * @param requestedWidth The width the window wants to be.
     * @param requestedHeight The height the window wants to be.
     * @param viewVisibility Window root view's visibility.
     * @param flags Request flags: {@link WindowManagerGlobal#RELAYOUT_INSETS_PENDING},
     * {@link WindowManagerGlobal#RELAYOUT_DEFER_SURFACE_DESTROY}.
     * @param frameNumber A frame number in which changes requested in this layout will be rendered.
     * @param outFrame Rect in which is placed the new position/size on
     * screen.
     * @param outOverscanInsets Rect in which is placed the offsets from
     * <var>outFrame</var> in which the content of the window are inside
     * of the display's overlay region.
     * @param outContentInsets Rect in which is placed the offsets from
     * <var>outFrame</var> in which the content of the window should be
     * placed.  This can be used to modify the window layout to ensure its
     * contents are visible to the user, taking into account system windows
     * like the status bar or a soft keyboard.
     * @param outVisibleInsets Rect in which is placed the offsets from
     * <var>outFrame</var> in which the window is actually completely visible
     * to the user.  This can be used to temporarily scroll the window's
     * contents to make sure the user can see it.  This is different than
     * <var>outContentInsets</var> in that these insets change transiently,
     * so complex relayout of the window should not happen based on them.
     * @param outOutsets Rect in which is placed the dead area of the screen that we would like to
     * treat as real display. Example of such area is a chin in some models of wearable devices.
     * @param outBackdropFrame Rect which is used draw the resizing background during a resize
     * operation.
     * @param outMergedConfiguration New config container that holds global, override and merged
     * config for window, if it is now becoming visible and the merged configuration has changed
     * since it was last displayed.
     * @param outSurface Object in which is placed the new display surface.
     *
     * @return int Result flags: {@link WindowManagerGlobal#RELAYOUT_SHOW_FOCUS},
     * {@link WindowManagerGlobal#RELAYOUT_FIRST_TIME}.
     */
    int relayout(IWindow window, int seq, in WindowManager.LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewVisibility,
            int flags, long frameNumber, out Rect outFrame, out Rect outOverscanInsets,
            out Rect outContentInsets, out Rect outVisibleInsets, out Rect outStableInsets,
            out Rect outOutsets, out Rect outBackdropFrame,
            out DisplayCutout.ParcelableWrapper displayCutout,
            out MergedConfiguration outMergedConfiguration, out Surface outSurface);

    /*
     * Notify the window manager that an application is relaunching and
     * windows should be prepared for replacement.
     *
     * @param appToken The application
     * @param childrenOnly Whether to only prepare child windows for replacement
     * (for example when main windows are being reused via preservation).
     */
    void prepareToReplaceWindows(IBinder appToken, boolean childrenOnly);

    /**
     * Called by a client to report that it ran out of graphics memory.
     */
    boolean outOfMemory(IWindow window);

    /**
     * Give the window manager a hint of the part of the window that is
     * completely transparent, allowing it to work with the surface flinger
     * to optimize compositing of this part of the window.
     */
    void setTransparentRegion(IWindow window, in Region region);

    /**
     * Tell the window manager about the content and visible insets of the
     * given window, which can be used to adjust the <var>outContentInsets</var>
     * and <var>outVisibleInsets</var> values returned by
     * {@link #relayout relayout()} for windows behind this one.
     *
     * @param touchableInsets Controls which part of the window inside of its
     * frame can receive pointer events, as defined by
     * {@link android.view.ViewTreeObserver.InternalInsetsInfo}.
     */
    void setInsets(IWindow window, int touchableInsets, in Rect contentInsets,
            in Rect visibleInsets, in Region touchableRegion);

    /**
     * Return the current display size in which the window is being laid out,
     * accounting for screen decorations around it.
     */
    void getDisplayFrame(IWindow window, out Rect outDisplayFrame);

    void finishDrawing(IWindow window);

    void setInTouchMode(boolean showFocus);
    boolean getInTouchMode();

    boolean performHapticFeedback(IWindow window, int effectId, boolean always);

    /**
     * Initiate the drag operation itself
     *
     * @param window Window which initiates drag operation.
     * @param flags See {@code View#startDragAndDrop}
     * @param surface Surface containing drag shadow image
     * @param touchSource See {@code InputDevice#getSource()}
     * @param touchX X coordinate of last touch point
     * @param touchY Y coordinate of last touch point
     * @param thumbCenterX X coordinate for the position within the shadow image that should be
     *         underneath the touch point during the drag and drop operation.
     * @param thumbCenterY Y coordinate for the position within the shadow image that should be
     *         underneath the touch point during the drag and drop operation.
     * @param data Data transferred by drag and drop
     * @return Token of drag operation which will be passed to cancelDragAndDrop.
     */
    IBinder performDrag(IWindow window, int flags, in SurfaceControl surface, int touchSource,
            float touchX, float touchY, float thumbCenterX, float thumbCenterY, in ClipData data);

    /**
     * Report the result of a drop action targeted to the given window.
     * consumed is 'true' when the drop was accepted by a valid recipient,
     * 'false' otherwise.
     */
    void reportDropResult(IWindow window, boolean consumed);

    /**
     * Cancel the current drag operation.
     */
    void cancelDragAndDrop(IBinder dragToken);

    /**
     * Tell the OS that we've just dragged into a View that is willing to accept the drop
     */
    void dragRecipientEntered(IWindow window);

    /**
     * Tell the OS that we've just dragged *off* of a View that was willing to accept the drop
     */
    void dragRecipientExited(IWindow window);

    /**
     * For windows with the wallpaper behind them, and the wallpaper is
     * larger than the screen, set the offset within the screen.
     * For multi screen launcher type applications, xstep and ystep indicate
     * how big the increment is from one screen to another.
     */
    void setWallpaperPosition(IBinder windowToken, float x, float y, float xstep, float ystep);

    void wallpaperOffsetsComplete(IBinder window);

    /**
     * Apply a raw offset to the wallpaper service when shown behind this window.
     */
    void setWallpaperDisplayOffset(IBinder windowToken, int x, int y);

    Bundle sendWallpaperCommand(IBinder window, String action, int x, int y,
            int z, in Bundle extras, boolean sync);

    void wallpaperCommandComplete(IBinder window, in Bundle result);

    /**
     * Notifies that a rectangle on the screen has been requested.
     */
    void onRectangleOnScreenRequested(IBinder token, in Rect rectangle);

    IWindowId getWindowId(IBinder window);

    /**
     * When the system is dozing in a low-power partially suspended state, pokes a short
     * lived wake lock and ensures that the display is ready to accept the next frame
     * of content drawn in the window.
     *
     * This mechanism is bound to the window rather than to the display manager or the
     * power manager so that the system can ensure that the window is actually visible
     * and prevent runaway applications from draining the battery.  This is similar to how
     * FLAG_KEEP_SCREEN_ON works.
     *
     * This method is synchronous because it may need to acquire a wake lock before returning.
     * The assumption is that this method will be called rather infrequently.
     */
    void pokeDrawLock(IBinder window);

    /**
     * Starts a task window move with {startX, startY} as starting point. The amount of move
     * will be the offset between {startX, startY} and the new cursor position.
     *
     * Returns true if the move started successfully; false otherwise.
     */
    boolean startMovingTask(IWindow window, float startX, float startY);

    void updatePointerIcon(IWindow window);

    /**
     * Update a tap exclude region with a rectangular area identified by provided id in the window.
     * Touches on this region will not switch focus to this window. Passing an empty rect will
     * remove the area from the exclude region of this window.
     */
    void updateTapExcludeRegion(IWindow window, int regionId, int left, int top, int width,
            int height);
}
```



# IWindowManager.aidl

```
/*
** Copyright 2006, The Android Open Source Project
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

package android.view;

import com.android.internal.os.IResultReceiver;
import com.android.internal.view.IInputContext;
import com.android.internal.view.IInputMethodClient;
import com.android.internal.policy.IKeyguardDismissCallback;
import com.android.internal.policy.IShortcutService;

import android.app.IAssistDataReceiver;
import android.content.res.CompatibilityInfo;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.GraphicBuffer;
import android.graphics.Point;
import android.graphics.Rect;
import android.graphics.Region;
import android.os.Bundle;
import android.os.IRemoteCallback;
import android.os.ParcelFileDescriptor;
import android.view.IApplicationToken;
import android.view.IAppTransitionAnimationSpecsFuture;
import android.view.IDockedStackListener;
import android.view.IOnKeyguardExitResult;
import android.view.IPinnedStackListener;
import android.view.RemoteAnimationAdapter;
import android.view.IRotationWatcher;
import android.view.IWallpaperVisibilityListener;
import android.view.IWindowSession;
import android.view.IWindowSessionCallback;
import android.view.KeyEvent;
import android.view.InputEvent;
import android.view.MagnificationSpec;
import android.view.MotionEvent;
import android.view.InputChannel;
import android.view.InputDevice;
import android.view.IInputFilter;
import android.view.AppTransitionAnimationSpec;
import android.view.WindowContentFrameStats;
import android.view.WindowManager;

/**
 * System private interface to the window manager.
 *
 * {@hide}
 */
interface IWindowManager
{
    /**
     * ===== NOTICE =====
     * The first three methods must remain the first three methods. Scripts
     * and tools rely on their transaction number to work properly.
     */
    // This is used for debugging
    boolean startViewServer(int port);   // Transaction #1
    boolean stopViewServer();            // Transaction #2
    boolean isViewServerRunning();       // Transaction #3

    IWindowSession openSession(in IWindowSessionCallback callback, in IInputMethodClient client,
            in IInputContext inputContext);
    boolean inputMethodClientHasFocus(IInputMethodClient client);

    void getInitialDisplaySize(int displayId, out Point size);
    void getBaseDisplaySize(int displayId, out Point size);
    void setForcedDisplaySize(int displayId, int width, int height);
    void clearForcedDisplaySize(int displayId);
    int getInitialDisplayDensity(int displayId);
    int getBaseDisplayDensity(int displayId);
    void setForcedDisplayDensityForUser(int displayId, int density, int userId);
    void clearForcedDisplayDensityForUser(int displayId, int userId);
    void setForcedDisplayScalingMode(int displayId, int mode); // 0 = auto, 1 = disable

    void setOverscan(int displayId, int left, int top, int right, int bottom);

    // These can only be called when holding the MANAGE_APP_TOKENS permission.
    void setEventDispatching(boolean enabled);
    void addWindowToken(IBinder token, int type, int displayId);
    void removeWindowToken(IBinder token, int displayId);
    void setFocusedApp(IBinder token, boolean moveFocusNow);
    void prepareAppTransition(int transit, boolean alwaysKeepCurrent);
    int getPendingAppTransition();
    void overridePendingAppTransition(String packageName, int enterAnim, int exitAnim,
            IRemoteCallback startedCallback);
    void overridePendingAppTransitionScaleUp(int startX, int startY, int startWidth,
            int startHeight);
    void overridePendingAppTransitionClipReveal(int startX, int startY,
            int startWidth, int startHeight);
    void overridePendingAppTransitionThumb(in GraphicBuffer srcThumb, int startX, int startY,
            IRemoteCallback startedCallback, boolean scaleUp);
    void overridePendingAppTransitionAspectScaledThumb(in GraphicBuffer srcThumb, int startX,
            int startY, int targetWidth, int targetHeight, IRemoteCallback startedCallback,
            boolean scaleUp);
    /**
     * Overrides animation for app transition that exits from an application to a multi-window
     * environment and allows specifying transition animation parameters for each window.
     *
     * @param specs Array of transition animation descriptions for entering windows.
     *
     * @hide
     */
    void overridePendingAppTransitionMultiThumb(in AppTransitionAnimationSpec[] specs,
            IRemoteCallback startedCallback, IRemoteCallback finishedCallback, boolean scaleUp);
    void overridePendingAppTransitionInPlace(String packageName, int anim);

    /**
     * Like overridePendingAppTransitionMultiThumb, but uses a future to supply the specs. This is
     * used for recents, where generating the thumbnails of the specs takes a non-trivial amount of
     * time, so we want to move that off the critical path for starting the new activity.
     */
    void overridePendingAppTransitionMultiThumbFuture(
            IAppTransitionAnimationSpecsFuture specsFuture, IRemoteCallback startedCallback,
            boolean scaleUp);
    void overridePendingAppTransitionRemote(in RemoteAnimationAdapter remoteAnimationAdapter);
    void executeAppTransition();

    /**
      * Used by system ui to report that recents has shown itself.
      * @deprecated to be removed once prebuilts are updated
      */
    void endProlongedAnimations();

    // Re-evaluate the current orientation from the caller's state.
    // If there is a change, the new Configuration is returned and the
    // caller must call setNewConfiguration() sometime later.
    Configuration updateOrientationFromAppTokens(in Configuration currentConfig,
            IBinder freezeThisOneIfNeeded, int displayId);
    // Notify window manager of the new display override configuration. Returns an array of stack
    // ids that were affected by the update, ActivityManager should resize these stacks.
    int[] setNewDisplayOverrideConfiguration(in Configuration overrideConfig, int displayId);

    void startFreezingScreen(int exitAnim, int enterAnim);
    void stopFreezingScreen();

    // these require DISABLE_KEYGUARD permission
    void disableKeyguard(IBinder token, String tag);
    void reenableKeyguard(IBinder token);
    void exitKeyguardSecurely(IOnKeyguardExitResult callback);
    boolean isKeyguardLocked();
    boolean isKeyguardSecure();
    void dismissKeyguard(IKeyguardDismissCallback callback, CharSequence message);

    // Requires INTERACT_ACROSS_USERS_FULL permission
    void setSwitchingUser(boolean switching);

    void closeSystemDialogs(String reason);

    // These can only be called with the SET_ANIMATON_SCALE permission.
    float getAnimationScale(int which);
    float[] getAnimationScales();
    void setAnimationScale(int which, float scale);
    void setAnimationScales(in float[] scales);

    float getCurrentAnimatorScale();

    // For testing
    void setInTouchMode(boolean showFocus);

    // For StrictMode flashing a red border on violations from the UI
    // thread.  The uid/pid is implicit from the Binder call, and the Window
    // Manager uses that to determine whether or not the red border should
    // actually be shown.  (it will be ignored that pid doesn't have windows
    // on screen)
    void showStrictModeViolation(boolean on);

    // Proxy to set the system property for whether the flashing
    // should be enabled.  The 'enabled' value is null or blank for
    // the system default (differs per build variant) or any valid
    // boolean string as parsed by SystemProperties.getBoolean().
    void setStrictModeVisualIndicatorPreference(String enabled);

    /**
     * Set whether screen capture is disabled for all windows of a specific user from
     * the device policy cache.
     */
    void refreshScreenCaptureDisabled(int userId);

    // These can only be called with the SET_ORIENTATION permission.
    /**
     * Update the current screen rotation based on the current state of
     * the world.
     * @param alwaysSendConfiguration Flag to force a new configuration to
     * be evaluated.  This can be used when there are other parameters in
     * configuration that are changing.
     * @param forceRelayout If true, the window manager will always do a relayout
     * of its windows even if the rotation hasn't changed.
     */
    void updateRotation(boolean alwaysSendConfiguration, boolean forceRelayout);

    /**
     * Retrieve the current orientation of the primary screen.
     * @return Constant as per {@link android.view.Surface.Rotation}.
     *
     * @see android.view.Display#DEFAULT_DISPLAY
     */
    int getDefaultDisplayRotation();

    /**
     * Watch the rotation of the specified screen.  Returns the current rotation,
     * calls back when it changes.
     */
    int watchRotation(IRotationWatcher watcher, int displayId);

    /**
     * Remove a rotation watcher set using watchRotation.
     * @hide
     */
    void removeRotationWatcher(IRotationWatcher watcher);

    /**
     * Determine the preferred edge of the screen to pin the compact options menu against.
     * @return a Gravity value for the options menu panel
     * @hide
     */
    int getPreferredOptionsPanelGravity();

    /**
     * Lock the device orientation to the specified rotation, or to the
     * current rotation if -1.  Sensor input will be ignored until
     * thawRotation() is called.
     * @hide
     */
    void freezeRotation(int rotation);

    /**
     * Release the orientation lock imposed by freezeRotation().
     * @hide
     */
    void thawRotation();

    /**
     * Gets whether the rotation is frozen.
     *
     * @return Whether the rotation is frozen.
     */
    boolean isRotationFrozen();

    /**
     * Screenshot the current wallpaper layer, including the whole screen.
     */
    Bitmap screenshotWallpaper();

    /**
     * Registers a wallpaper visibility listener.
     * @return Current visibility.
     */
    boolean registerWallpaperVisibilityListener(IWallpaperVisibilityListener listener,
        int displayId);

    /**
     * Remove a visibility watcher that was added using registerWallpaperVisibilityListener.
     */
    void unregisterWallpaperVisibilityListener(IWallpaperVisibilityListener listener,
        int displayId);

    /**
     * Used only for assist -- request a screenshot of the current application.
     */
    boolean requestAssistScreenshot(IAssistDataReceiver receiver);

    /**
     * Called by the status bar to notify Views of changes to System UI visiblity.
     */
    oneway void statusBarVisibilityChanged(int visibility);

    /**
     * Called by System UI to notify of changes to the visibility of Recents.
     */
    oneway void setRecentsVisibility(boolean visible);

    /**
     * Called by System UI to notify of changes to the visibility of PIP.
     */
    oneway void setPipVisibility(boolean visible);

    /**
     * Called by System UI to notify of changes to the visibility and height of the shelf.
     */
    void setShelfHeight(boolean visible, int shelfHeight);

    /**
     * Called by System UI to enable or disable haptic feedback on the navigation bar buttons.
     */
    void setNavBarVirtualKeyHapticFeedbackEnabled(boolean enabled);

    /**
     * Device has a software navigation bar (separate from the status bar).
     */
    boolean hasNavigationBar();

    /**
     * Get the position of the nav bar
     */
    int getNavBarPosition();

    /**
     * Lock the device immediately with the specified options (can be null).
     */
    void lockNow(in Bundle options);

    /**
     * Device is in safe mode.
     */
    boolean isSafeModeEnabled();

    /**
     * Enables the screen if all conditions are met.
     */
    void enableScreenIfNeeded();

    /**
     * Clears the frame statistics for a given window.
     *
     * @param token The window token.
     * @return Whether the frame statistics were cleared.
     */
    boolean clearWindowContentFrameStats(IBinder token);

    /**
     * Gets the content frame statistics for a given window.
     *
     * @param token The window token.
     * @return The frame statistics or null if the window does not exist.
     */
    WindowContentFrameStats getWindowContentFrameStats(IBinder token);

    /**
     * @return the dock side the current docked stack is at; must be one of the
     *         WindowManagerGlobal.DOCKED_* values
     */
    int getDockedStackSide();

    /**
     * Sets the region the user can touch the divider. This region will be excluded from the region
     * which is used to cause a focus switch when dispatching touch.
     */
    void setDockedStackDividerTouchRegion(in Rect touchableRegion);

    /**
     * Registers a listener that will be called when the dock divider changes its visibility or when
     * the docked stack gets added/removed.
     */
    void registerDockedStackListener(IDockedStackListener listener);

    /**
     * Registers a listener that will be called when the pinned stack state changes.
     */
    void registerPinnedStackListener(int displayId, IPinnedStackListener listener);

    /**
     * Updates the dim layer used while resizing.
     *
     * @param visible Whether the dim layer should be visible.
     * @param targetWindowingMode The windowing mode of the stack the dim layer should be placed on.
     * @param alpha The translucency of the dim layer, between 0 and 1.
     */
    void setResizeDimLayer(boolean visible, int targetWindowingMode, float alpha);

    /**
     * Requests Keyboard Shortcuts from the displayed window.
     *
     * @param receiver The receiver to deliver the results to.
     */
    void requestAppKeyboardShortcuts(IResultReceiver receiver, int deviceId);

    /**
     * Retrieves the current stable insets from the primary display.
     */
    void getStableInsets(int displayId, out Rect outInsets);

    /**
     * Register shortcut key. Shortcut code is packed as:
     * (MetaState << Integer.SIZE) | KeyCode
     * @hide
     */
    void registerShortcutKey(in long shortcutCode, IShortcutService keySubscriber);

    /**
     * Create an input consumer by name.
     */
    void createInputConsumer(IBinder token, String name, out InputChannel inputChannel);

    /**
     * Destroy an input consumer by name.  This method will also dispose the input channels
     * associated with that InputConsumer.
     */
    boolean destroyInputConsumer(String name);

    /**
     * Return the touch region for the current IME window, or an empty region if there is none.
     */
    Region getCurrentImeTouchRegion();

    /**
     * Starts a window trace.
     */
    void startWindowTrace();

    /**
     * Stops a window trace.
     */
    void stopWindowTrace();

    /**
     * Returns true if window trace is enabled.
     */
    boolean isWindowTraceEnabled();

    /**
     * Requests that the WindowManager sends WindowManagerPolicy#ACTION_USER_ACTIVITY_NOTIFICATION
     * on the next user activity.
     */
    void requestUserActivityNotification();

    /**
     * Notify WindowManager that it should not override the info in DisplayManager for the specified
     * display. This can disable letter- or pillar-boxing applied in DisplayManager when the metrics
     * of the logical display reported from WindowManager do not correspond to the metrics of the
     * physical display it is based on.
     *
     * @param displayId The id of the display.
     */
    void dontOverrideDisplayInfo(int displayId);
}
```



# IInputMethod.aidl

```
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.internal.view;

import android.os.IBinder;
import android.os.ResultReceiver;
import android.view.InputChannel;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputBinding;
import android.view.inputmethod.InputMethodSubtype;
import com.android.internal.view.IInputContext;
import com.android.internal.view.IInputMethodSession;
import com.android.internal.view.IInputSessionCallback;

/**
 * Top-level interface to an input method component (implemented in a
 * Service).
 * {@hide}
 */
oneway interface IInputMethod {
    void attachToken(IBinder token);

    void bindInput(in InputBinding binding);

    void unbindInput();

    void startInput(in IBinder startInputToken, in IInputContext inputContext, int missingMethods,
            in EditorInfo attribute, boolean restarting);

    void createSession(in InputChannel channel, IInputSessionCallback callback);

    void setSessionEnabled(IInputMethodSession session, boolean enabled);

    void revokeSession(IInputMethodSession session);

    void showSoftInput(int flags, in ResultReceiver resultReceiver);

    void hideSoftInput(int flags, in ResultReceiver resultReceiver);

    void changeInputMethodSubtype(in InputMethodSubtype subtype);
}
```



# input_method.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
/* //device/apps/common/res/layout/alert_dialog.xml
**
** Copyright 2006, The Android Open Source Project
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/
-->

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/parentPanel"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    >

    <LinearLayout
        android:id="@+id/fullscreenArea"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        >

        <FrameLayout android:id="@android:id/extractArea"
            android:layout_width="match_parent"
            android:layout_height="0px"
            android:layout_weight="1"
            android:visibility="gone">
        </FrameLayout>
        
        <FrameLayout android:id="@android:id/candidatesArea"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:visibility="invisible">
        </FrameLayout>

    </LinearLayout>
            
    <FrameLayout android:id="@android:id/inputArea"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:visibility="gone">
    </FrameLayout>

</LinearLayout>
```



# AIDL

## 客户端

### Book.aidl

```
package com.;

parcelable Book;

interface Book {
	void basicType(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);
}
```

### Book.java

```
/**
 * 作者：叶应是叶
 * 时间：2017/8/25 23:31
 * 描述：
 */
public class Book implements Parcelable {

    private String name;

    public Book(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "book name：" + name;
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(this.name);
    }

    public void readFromParcel(Parcel dest) {
        name = dest.readString();
    }

    protected Book(Parcel in) {
        this.name = in.readString();
    }

    public static final Creator<Book> CREATOR = new Creator<Book>() {
        @Override
        public Book createFromParcel(Parcel source) {
            return new Book(source);
        }

        @Override
        public Book[] newArray(int size) {
            return new Book[size];
        }
    };
}
    
```

### BookController

```
interface BookController{
	List<Book> getBookList();
	void addBookInOut(inout Book book);
}
```



### 客户端代码

```
private ServiceConnection serviceConnection = new ServiceConnection(){
	@Override
	public void onServiceConnected(ComponentName name, IBinder service) {
		bookController = BookController.Stub.asInterface(service);
		connected = true;
	}
	
	@Override
	public void onServiceDisconnected(ComponentName name) {
		connected = false;
	}
}
```



## 服务端

### AIDLService

```
public class AIDLService extends Service {
	private final String TAG = "Server";
	
	private List<Book> bookList;
	public AIDLService(){
	
	}
	@Override
	public void onCreate(){
		super.onCreate();
		bookList = new ArrayList();
		initData();
	}
	private void initData(){
        Book book1 = new Book("活着");
        Book book2 = new Book("或者");
        Book book3 = new Book("叶应是叶");
        Book book4 = new Book("https://github.com/leavesC");
        Book book5 = new Book("http://www.jianshu.com/u/9df45b87cfdf");
        Book book6 = new Book("http://blog.csdn.net/new_one_object");
        bookList.add(book1);
        bookList.add(book2);
        bookList.add(book3);
        bookList.add(book4);
        bookList.add(book5);
        bookList.add(book6);
	}
	
	private  final BookController.Stub stub = new BookController.Stub(){
		
		@Override
		public List<Book> getBookList() throws RemoteException{
			return bookList;
		}
		
		@Override
		pubic void addBookInOut(Book book) throws RemoteException{
			if(book != null) {
				 book.setName("服务器改了新书的名字 InOut");
         bookList.add(book);
			} else {
				Log.e(TAG, "接收到了一个空对象 InOut");
			}
		}
		
		@Override
		public IBinder onBind(Intent intent){
			return stub;
		}
	}
}
```





# [Android 获取键盘高度，显示键盘和隐藏键盘](https://blog.csdn.net/u010218170/article/details/90579833)

```
// 最小键盘高度的阈值
final int MIN_KEYBOARD_HEIGHT_PX = 200
// 屏幕可见区域
private final Rect windowVisibleDisplayFrame = new Rect();
// 保存最后可视区域高度
private int lastKeyBoarHeight;
private ViewTreeObserver.OnGlobalLayoutListener onGlobalLayoutListener = new ViewTreeObserver.OnGlobalLayoutListener(){
	@Override
	public void onGlobalLayout(){
		//获取屏幕可视区域
		activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(windowVisibleDisplayFrame);
		//获取键盘的高度
		
		int currentKeyboardHeight = activity.getWindow().getDecorView().getHeight() - windowVisibleDisplayFrame.bottom;
		if(lastKeyboardHeight != currentKeyboardHeight){
			if(currentKeyboardHeight > MIN_KEYBOARD_HEIGHT_PX) { //键盘可见回调
				if(onKeyboardListener != null) {
					onKeyboardListener.onKeyboardShown(currentKeyboardHeight);
				}
			} else { //键盘隐藏时回调
				if(onKeyboardListener != null) {
					onKeyboardListener.onKeyboardHidden();
				}
			}
			lastKeyboardHeight = currentKeyboardHeight;
		} 
	}
}
```

